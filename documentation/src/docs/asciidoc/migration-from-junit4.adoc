[[migrating-from-junit4]]
== Migrating from JUnit 4

Although the JUnit Jupiter programming model and extension model will not support JUnit 4
features such as `Rules` and `Runners` natively, it is not expected that source code maintainers
will need to update all of their existing tests, test extensions, and custom build test
infrastructure to migrate to JUnit Jupiter.

Instead, JUnit provides a gentle migration path via a _JUnit Vintage test engine_ which
allows existing tests based on JUnit 3 and JUnit 4 to be executed using the JUnit
Platform infrastructure. Since all classes and annotations specific to JUnit Jupiter
reside under a new `org.junit.jupiter` base package, having both JUnit 4 and JUnit
Jupiter in the classpath does not lead to any conflicts. It is therefore safe to maintain
existing JUnit 4 tests alongside JUnit Jupiter tests. Furthermore, since the JUnit team
will continue to provide maintenance and bug fix releases for the JUnit 4.x baseline,
developers have plenty of time to migrate to JUnit Jupiter on their own schedule.

[[migrating-from-junit4-running]]
=== Running JUnit 4 Tests on the JUnit Platform

Just make sure that the `junit-vintage-engine` artifact is in your test runtime path. In that
case JUnit 3 and JUnit 4 tests will automatically be picked up by the JUnit Platform launcher.

See the example projects in the {junit5-samples-repo}[`junit5-samples`] repository to
find out how this is done with Gradle and Maven.

[[migrating-from-junit4-tips]]
=== Migration Tips

The following are things you have to watch out for when migrating existing JUnit 4 tests
to JUnit Jupiter.

* Annotations reside in the `org.junit.jupiter.api` package.
* Assertions reside in `org.junit.jupiter.api.Assertions`.
* Assumptions reside in `org.junit.jupiter.api.Assumptions`.
* `@Before` and `@After` no longer exist; use `@BeforeEach` and `@AfterEach` instead.
* `@BeforeClass` and `@AfterClass` no longer exist; use `@BeforeAll` and `@AfterAll` instead.
* `@Ignore` no longer exists: use `@Disabled` instead.
* `@Category` no longer exists; use `@Tag` instead.
* `@RunWith` no longer exists; superseded by `@ExtendWith`.
* `@Rule` and `@ClassRule` no longer exist; superseded by `@ExtendWith`;
   see the following section for partial rule support.

[[migrating-from-junit4-rulesupport]]
=== Limited JUnit 4 Rule Support

As stated above, JUnit Jupiter does not and will not support JUnit 4 rules natively.
The JUnit team realizes, however, that many organizations, especially large ones,
are likely to have large JUnit 4 codebases including custom rules.
To serve these organizations and enable a gradual migration path the JUnit team has decided
to support a selection of JUnit 4 rules verbatim within JUnit Jupiter.
This support is based on adapters and is limited to those rules
that are semantically compatible to the JUnit Jupiter extension model,
i.e. those that do not completely change the overall execution flow of the test.

JUnit Jupiter currently supports the following three Rule types including subclasses
of those types:

* `org.junit.rules.ExternalResource` (including `org.junit.rules.TemporaryFolder`)
* `org.junit.rules.Verifier` (including `org.junit.rules.ErrorCollector`)
* `org.junit.rules.ExpectedException`

As in JUnit 4, Rule-annotated fields as well as methods are supported.
By using these class-level extensions on a test class such Rule implementations
in legacy codebases can be _left unchanged_ including the JUnit 4 rule import statements.

This limited form of Rule support can be switched on by the class-level annotation
`org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport`.
This annotation is a _composed annotation_ which enables all migration
support extensions: `VerifierSupport`, `ExternalResourceSupport`, and `ExpectedExceptionSupport`.

However, if you intend to develop a new extension for JUnit 5
please use the new extension model of JUnit Jupiter instead of the rule-based model of JUnit 4.

[[migrating-from-junit4-rule-replacement]]
=== Replacing JUnit 4 Rules

JUnit 5 may only have limited JUnit 4 rule support but the use-cases that originally
led to the creation of the built-in JUnit 4 rules are still important.  This section
provides patterns that demonstrate how a test writer might accomplish the same tasks
using the framework provided by JUnit 5.

Below you'll find  a section for each of the JUnit 4 rules that shows the original sample
code (sometimes modified so that it will actually execute) as well as an example that
provides the same functionality in JUnit 5.

==== DisableOnDebug

As the only discernable use for this rule is to disable the `Timeout` rule, the
JUnit 5 team has decided not to support this functionality at this time.

==== ErrorCollector (Verifier)

==== ExpectedException

==== RuleChain

==== Stopwatch

JUnit 4's `Stopwatch` rule performs two functions - it allows a test writer to
determine the result of the test as well as the execution time of the test.  The
following code is a combination of the two examples provided with the JUnit 4
Stopwatch rule.

[caption="StopwatchVintageDemo.java"]
[source,java,indent=0]
[subs="verbatim"]
----
include::{testDir}/example/testrule/StopwatchVintageDemo.java[tags=user_guide]
----

Executing this code results in the following log output:

[caption="StopwatchVintageDemo.out"]
[source,text,indent=0]
[subs="verbatim"]
----
include::{testDir}/example/testrule/StopwatchVintageDemo.out[tags=user_guide]
----

Note that there are two lines output to the log files for each of the tests that
are run since one line is output by the methods that indicate the test results
(succeeded, failed, skipped) and a second line is output regardless of the test
outcome (finished).

JUnit 5 provides the result of the test to the all registered `TestExecutionListener`
(s), so the `StopwatchExtension` and `Stopwatch` object which can be injected into
the test via `ParameterResolution` simply need to allow the test execution time to
be recorded and then provide it to the `TestExecutionListener` .  Here's the
JUnit 5 code that provides (along with the `StopwatchExtension` ) the equivalent
functionality:

[caption="StopwatchJupiterDemo.java"]
[source,java,indent=0]
[subs="verbatim"]
----
include::{testDir}/example/testrule/StopwatchJupiterDemo.java[tags=user_guide]
----

There are three important points to note in this code:

1.  We add the `StopwatchExtension` to the class-under-test - this will result in the
execution time of each test being output to the `TestExecutionListener` as a
`ReportEntry` .  Since `ReportEntry` objects are key/value pairs, a custom
`TestExecutionListener` could conceivably perform operations on the values returned
by the extension.  (e.g. to sum all execution times).

2.  An instance of a `Stopwatch` is injected into the test when we want to make
assertions about the execution time.

3.  When we're making an assertion about the test's execution time, we can choose the
`TimeUnit` for the comparison but since the result is a double, we must also provide
a delta that's sufficient to account for deviations in the system's timing.

When this code is executed, it produces the following output (shown using the
default Gradle test tree printer):

[caption="StopwatchJupiterDemo.out"]
[source,text,indent=0]
[subs="verbatim"]
----
include::{testDir}/example/testrule/StopwatchJupiterDemo.out[tags=user_guide]
----

==== TemporaryFolder (ExternalResource)

==== TestName (TestWatcher)

==== Timeout
